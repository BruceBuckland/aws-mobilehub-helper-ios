//
//  AWSIdentityManager.m
//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to
// copy, distribute and modify it.
//

#import "AWSIdentityManager.h"
#import "AWSSignInProvider.h"
#import "AWSFacebookSignInProvider.h"
#import "AWSGoogleSignInProvider.h"

NSString *const AWSIdentityManagerDidSignInNotification = @"com.amazonaws.AWSIdentityManager.AWSIdentityManagerDidSignInNotification";
NSString *const AWSIdentityManagerDidSignOutNotification = @"com.amazonaws.AWSIdentityManager.AWSIdentityManagerDidSignOutNotification";
NSString *const AWSIdentityManagerUserDefaultsProvidersOk = @"com.amazonaws.AWSIdentityManager.ProvidersOk";

typedef void (^AWSIdentityManagerCompletionBlock)(id result, NSError *error);

@interface AWSIdentityManager()

@property (nonatomic, strong) AWSCognitoCredentialsProvider *credentialsProvider;
@property (atomic, copy) AWSIdentityManagerCompletionBlock completionHandler;

@property (nonatomic, strong) id<AWSSignInProvider> currentSignInProvider;
@property (nonatomic, strong) id<AWSSignInProvider> lastSignInProvider;

@end

@implementation AWSIdentityManager

// Enhancement support
NSDictionary<NSString *, NSString *> *loginCache; // Be a "real" AWSIdentityProviderManager
BOOL mergingIdentityProviderManager; // Switch to allow or reject identity merging
BOOL multiAccountIdentityProviderManager; // Switch to allow or reject stacked logins
BOOL doNotInitProviders; // Switch true if last shutdown was graceless

static NSString *const AWSInfoIdentityManager = @"IdentityManager";
static NSString *const AWSInfoRoot = @"AWS";
static NSString *const AWSInfoMobileHub = @"MobileHub";
static NSString *const AWSInfoProjectClientId = @"ProjectClientId";
static NSString *const AWSInfoAllowIdentityMerging = @"Allow Identity Merging";
static NSString *const AWSInfoAllowSimultaneousActiveAccounts = @"Allow Simultaneous Active Accounts";

+ (instancetype)defaultIdentityManager {
    static AWSIdentityManager *_defaultIdentityManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] defaultServiceInfo:AWSInfoIdentityManager];
        
        if (!serviceInfo) {
            @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                           reason:@"The service configuration is `nil`. You need to configure `Info.plist` before using this method."
                                         userInfo:nil];
        }
        _defaultIdentityManager = [[AWSIdentityManager alloc] initWithCredentialProvider:serviceInfo];
        loginCache = [[NSDictionary<NSString *, NSString *> alloc] init];
        if (!(mergingIdentityProviderManager = [[serviceInfo.infoDictionary valueForKey:AWSInfoAllowIdentityMerging] boolValue])) {
            mergingIdentityProviderManager = FALSE; // Mobile Hub Compatibility
        };
        if (!(multiAccountIdentityProviderManager =  [[serviceInfo.infoDictionary valueForKey:AWSInfoAllowSimultaneousActiveAccounts  ] boolValue])) {
            multiAccountIdentityProviderManager = FALSE; // Mobile Hub Compatibility
        };
        if (mergingIdentityProviderManager && !multiAccountIdentityProviderManager) {
            @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                           reason:@"Illegal Configuration - Allow Identity Merging requires Allow Simultaneous Active Accounts"
                                         userInfo:nil];
        }
        if ((doNotInitProviders = ![[NSUserDefaults standardUserDefaults] boolForKey:AWSIdentityManagerUserDefaultsProvidersOk])) {
            NSLog(@"Graceless exit detected");
        };


    });
    
    return _defaultIdentityManager;
}

- (instancetype)initWithCredentialProvider:(AWSServiceInfo *)serviceInfo {
    if (self = [super init]) {
        [AWSLogger defaultLogger].logLevel = AWSLogLevelVerbose;
        
        self.credentialsProvider = serviceInfo.cognitoCredentialsProvider;
        [self.credentialsProvider setIdentityProviderManagerOnce:self];
        
        // Init the ProjectTemplateId
        NSString *projectTemplateId = [[[AWSInfo defaultAWSInfo].rootInfoDictionary objectForKey:AWSInfoMobileHub] objectForKey:AWSInfoProjectClientId];
        if (!projectTemplateId) {
            projectTemplateId = @"MobileHub HelperFramework";
        }
        [AWSServiceConfiguration addGlobalUserAgentProductToken:projectTemplateId];
    }
    return self;
}

#pragma mark - AWSIdentityProviderManager

- (AWSTask<NSDictionary<NSString *, NSString *> *> *)logins {
    if (!self.currentSignInProvider) {
        return [AWSTask taskWithResult:nil];
    }
    return [[self.currentSignInProvider token] continueWithSuccessBlock:^id _Nullable(AWSTask<NSString *> * _Nonnull task) {
        NSString *token = task.result;
        [self mergeLogins:@{self.currentSignInProvider.identityProviderName : token}];
        return [AWSTask taskWithResult: loginCache];
    }];
}

- (void)mergeLogins:(NSDictionary<NSString *,NSString *> *)logins {
    if (!mergingIdentityProviderManager) {
        loginCache = [logins copy]; // not merging?  replace the cache with what they passed
    } else { // merging, add the new login to the cache
        NSMutableDictionary<NSString *, NSString *> *merge = [[NSMutableDictionary<NSString *, NSString *> alloc] init];
        merge = [loginCache mutableCopy];
        
        for (NSString* key in logins) {
            merge[key] = logins[key];
        }
        loginCache = [merge copy];
    }
}

- (void)dropLogin:(NSString *)key {
    NSMutableDictionary<NSString *, NSString *> *shorterList = [[NSMutableDictionary<NSString *, NSString *> alloc] init];
    shorterList = [loginCache mutableCopy];
    [shorterList removeObjectForKey: key];
    loginCache = [shorterList copy];
}

#pragma mark -

- (NSString *)identityId {
    return self.credentialsProvider.identityId;
}

- (BOOL)isLoggedIn {
    return self.currentSignInProvider.isLoggedIn;
}

- (NSURL *)imageURL {
    return self.currentSignInProvider.imageURL;
}

- (NSString *)userName {
    return self.currentSignInProvider.userName;
}

- (NSString *)email {
    return self.currentSignInProvider.email;
}

- (NSString *)phone {
    return self.currentSignInProvider.phone;
}

- (void)wipeAll {
    if (self.currentSignInProvider) { // fix login cache
        [self dropLogin: [self.currentSignInProvider identityProviderName]];
    }
    [self.credentialsProvider clearKeychain];
}

- (void)logoutWithCompletionHandler:(void (^)(id result, NSError *error))completionHandler {
    if ([self.currentSignInProvider isLoggedIn]) {
        [self.currentSignInProvider logout];
    }
    
    [self wipeAll];
    
    self.currentSignInProvider = nil;
    
    // if we still have an active session, getIdentityId will find it
    [self restartAnyExistingSessions: [UIApplication sharedApplication] didFinishLaunchingWithOptions:nil];
    
    [[self.credentialsProvider getIdentityId] continueWithBlock:^id _Nullable(AWSTask<NSString *> * _Nonnull task) {
        dispatch_async(dispatch_get_main_queue(), ^{
            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
            [notificationCenter postNotificationName:AWSIdentityManagerDidSignOutNotification
                                              object:[AWSIdentityManager defaultIdentityManager]
                                            userInfo:nil];
            if (task.exception) {
                AWSLogError(@"Fatal exception: [%@]", task.exception);
                kill(getpid(), SIGKILL);
            }
            completionHandler(task.result, task.error);
        });
        return nil;
    }];
}



- (void)loginWithSignInProvider:(id)signInProvider
              completionHandler:(void (^)(id result, NSError *error))completionHandler {

    // don't create multiple logins if the Allow Simultaneous Active Accounts is NO
    if (!multiAccountIdentityProviderManager  && self.currentSignInProvider) {
        // Do a quick and dirty logout, because we don't want to create a disabled ID
        // before logging in.
        [self.currentSignInProvider logout];
        [self wipeAll];
    }
    // allow multiple logins but don't merge the list
    if (multiAccountIdentityProviderManager && !mergingIdentityProviderManager && self.currentSignInProvider) {
        // We are logged in and want to remain logged in, but we need to empty the cache, and we want the
        // next attempt at credentials to start fresh
        // This allows multiple stacked logins without merging
        [self wipeAll];
    }
    self.lastSignInProvider = self.currentSignInProvider; // save for error recovery
    self.currentSignInProvider = signInProvider;
    
    self.completionHandler = completionHandler;
    [self.currentSignInProvider login:^void (id result, NSError *error) {
        if ( error != nil ) {
            // catch the completion handler so we can do some housekeeping
            self.currentSignInProvider = self.lastSignInProvider;
            [self.currentSignInProvider reloadSession]; // stay logged in
        }
        self.completionHandler(result,error);
    }];
}
//              (^AWSIdentityManagerCompletionBlock)(id result, NSError *error)
- (void)resumeSessionWithCompletionHandler:(AWSIdentityManagerCompletionBlock)completionHandler {

    // Wrap the completion handler in a closure that sets the all clear flag
    self.completionHandler = ^ (id result, NSError *error) {
        NSLog(@"Session resume complete - setting Providers Ok");
        NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
        [userDefaults setBool:YES
                       forKey:AWSIdentityManagerUserDefaultsProvidersOk];
        completionHandler(result, error);
    };

    for (id<AWSSignInProvider> provider  in [self activeProviders]) {
        [provider reloadSession]; // reload each of the providers that have active sessions
    }
    // do completeLogin to guarantee credentials if there are no sessions
    if ([[self activeProviders] count] == 0) {
              [self completeLogin];
    }
    doNotInitProviders = NO; // all init's have been started.  Crash will be detected next start
}

- (void)completeLogin {
    // Force a refresh of credentials to see if we need to merge
    [self.credentialsProvider invalidateCachedTemporaryCredentials];
    
    [[self.credentialsProvider credentials] continueWithBlock:^id _Nullable(AWSTask<AWSCredentials *> * _Nonnull task) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (task.exception) {
                AWSLogError(@"Fatal exception: [%@]", task.exception);
                kill(getpid(), SIGKILL);
            }
            // Cannot merge identities is a failed login, not logging in with
            // another provider.  And this error causes us to logout and
            // go look for other sessions to start.
            if (task.error.code == AWSCognitoIdentityErrorResourceConflict) {
                [self logoutWithCompletionHandler:^void (id result, NSError *error) {
                    if ( error != nil ) {
                        NSLog( @"Error from logoutWithCompletionHandler %@", error);
                    }
                    self.completionHandler(task.result, task.error); // done deliver result
                }];
            } else if (task.error) { // some sort of error - should NOT be a good sign in but log in NSLog and dont Notify
                NSLog(@"Could not get credentials - This should never happen %@", task.error);
                self.completionHandler(task.result, task.error); // palliative degradation, but Don't corrupt Dataset with DidSignIn notice
            } else { // no issues
                if (self.currentSignInProvider) { // won't have this if not authenticated
                    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
                    [notificationCenter postNotificationName:AWSIdentityManagerDidSignInNotification
                                                      object:[AWSIdentityManager defaultIdentityManager]
                                                    userInfo:nil];
                }
                self.completionHandler(task.result, task.error);
            }
        });
        return nil;
    }];
}

- (NSArray *)activeProviders {
    Class signInProviderClass = nil;
    NSMutableArray *providerArray;
    providerArray = [[NSMutableArray<id<AWSSignInProvider>> alloc] init ];
    AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] defaultServiceInfo:AWSInfoIdentityManager];
    NSDictionary *signInProviderKeyDictionary = [serviceInfo.infoDictionary objectForKey:@"SignInProviderKeyDictionary"];
    if (!signInProviderKeyDictionary) { // no keys list - do it the old way:
        // This maintains mobile hub compatibility
        // Do google first, so that Facebook sessions are preferred just
        // like before.
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"Google"]) {
            signInProviderClass = NSClassFromString(@"AWSGoogleSignInProvider");
            [providerArray addObject:[signInProviderClass sharedInstance]];
        }
        if ([[NSUserDefaults standardUserDefaults] objectForKey:@"Facebook"]) {
            signInProviderClass = NSClassFromString(@"AWSFacebookSignInProvider");
            [providerArray addObject:[signInProviderClass sharedInstance]];
        }
        if (signInProviderClass && !providerArray.lastObject) {
            NSLog(@"Unable to locate the SignIn Provider SDK. Signing Out any existing session...");
            [self wipeAll];
        }
        
    }
    
    
    // loop through the Info.plist
    // AWS->IdentityManager->Default->SignInProviderClassDictionary
    // and return provider list for any sessions found.
    for (NSString *key in signInProviderKeyDictionary) {
        if ([[NSUserDefaults standardUserDefaults] objectForKey:[signInProviderKeyDictionary objectForKey:key]]) {
            if (doNotInitProviders) { // previous exit was not graceful
                NSLog(@"Graceless exit - removing %@",key);
                [[NSUserDefaults standardUserDefaults] removeObjectForKey:[signInProviderKeyDictionary objectForKey:key]];
                [self wipeAll]; // once would be enough
            } else {
                signInProviderClass = NSClassFromString(key);
                [providerArray addObject:[signInProviderClass sharedInstance]]; // assemble list
                if (signInProviderClass && !providerArray.lastObject) {
                    NSLog(@"Unable to locate the SignIn Provider SDK for %@. Signing Out any existing session...", key);
                    [self wipeAll];
                }
                
            }
        }
    }
    return providerArray;
}

- (void)restartAnyExistingSessions:(UIApplication *)application
     didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  {
    // Restart any sessions found.
    for (id provider in [self activeProviders]) {
        
        self.currentSignInProvider = provider;
    }
    
    if (self.currentSignInProvider) {
        if (![self.currentSignInProvider interceptApplication:application
                                didFinishLaunchingWithOptions:launchOptions]) {
            NSLog(@"Unable to instantiate AWSSignInProvider for existing session.");
        }
    }
}

- (BOOL)interceptApplication:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    [userDefaults setBool:NO
                   forKey:AWSIdentityManagerUserDefaultsProvidersOk]; // Assume they are not ok
    [self restartAnyExistingSessions:application didFinishLaunchingWithOptions:launchOptions];
    return YES;
}

- (BOOL)interceptApplication:(UIApplication *)application
                     openURL:(NSURL *)url
           sourceApplication:(NSString *)sourceApplication
                  annotation:(id)annotation {
    if (self.currentSignInProvider) {
        return [self.currentSignInProvider interceptApplication:application
                                                        openURL:url
                                              sourceApplication:sourceApplication
                                                     annotation:annotation];
    }
    else {
        return YES;
    }
}

@end
